# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `netaddr` gem.
# Please instead update this file by running `bin/tapioca gem netaddr`.

# source://netaddr//lib/eui48.rb#1
module NetAddr
  private

  # ipv4_prefix_len returns the prefix length needed to hold the number of IP addresses specified by "size".
  #
  # source://netaddr//lib/netaddr.rb#26
  def ipv4_prefix_len(size); end

  # parse_ip parses a string into an IPv4 or IPv6
  #
  # source://netaddr//lib/netaddr.rb#41
  def parse_ip(ip); end

  # parse_net parses a string into an IPv4Net or IPv6Net
  #
  # source://netaddr//lib/netaddr.rb#50
  def parse_net(net); end

  # sort_IPv4 sorts a list of IPv4 objects in ascending order.
  # It will return a new list with any non IPv4 objects removed.
  #
  # source://netaddr//lib/netaddr.rb#60
  def sort_IPv4(list); end

  # sort_IPv4Net sorts a list of IPv4Net objects in ascending order.
  # It will return a new list with any non IPv4Net objects removed.
  #
  # source://netaddr//lib/netaddr.rb#82
  def sort_IPv4Net(list); end

  # sort_IPv6 sorts a list of IPv6 objects in ascending order.
  # It will return a new list with any non IPv6 objects removed.
  #
  # source://netaddr//lib/netaddr.rb#71
  def sort_IPv6(list); end

  # sort_IPv6Net sorts a list of IPv6Net objects in ascending order.
  # It will return a new list with any non IPv6Net objects removed.
  #
  # source://netaddr//lib/netaddr.rb#93
  def sort_IPv6Net(list); end

  # summ_IPv4Net summarizes a list of IPv4Net objects as much as possible.
  # It will return a new list with any non IPv4Net objects removed.
  #
  # source://netaddr//lib/netaddr.rb#104
  def summ_IPv4Net(list); end

  # summ_IPv6Net summarizes a list of IPv6Net objects as much as possible.
  # It will return a new list with any non IPv6Net objects removed.
  #
  # source://netaddr//lib/netaddr.rb#116
  def summ_IPv6Net(list); end

  class << self
    # ipv4_prefix_len returns the prefix length needed to hold the number of IP addresses specified by "size".
    #
    # source://netaddr//lib/netaddr.rb#26
    def ipv4_prefix_len(size); end

    # parse_ip parses a string into an IPv4 or IPv6
    #
    # source://netaddr//lib/netaddr.rb#41
    def parse_ip(ip); end

    # parse_net parses a string into an IPv4Net or IPv6Net
    #
    # source://netaddr//lib/netaddr.rb#50
    def parse_net(net); end

    # sort_IPv4 sorts a list of IPv4 objects in ascending order.
    # It will return a new list with any non IPv4 objects removed.
    #
    # source://netaddr//lib/netaddr.rb#60
    def sort_IPv4(list); end

    # sort_IPv4Net sorts a list of IPv4Net objects in ascending order.
    # It will return a new list with any non IPv4Net objects removed.
    #
    # source://netaddr//lib/netaddr.rb#82
    def sort_IPv4Net(list); end

    # sort_IPv6 sorts a list of IPv6 objects in ascending order.
    # It will return a new list with any non IPv6 objects removed.
    #
    # source://netaddr//lib/netaddr.rb#71
    def sort_IPv6(list); end

    # sort_IPv6Net sorts a list of IPv6Net objects in ascending order.
    # It will return a new list with any non IPv6Net objects removed.
    #
    # source://netaddr//lib/netaddr.rb#93
    def sort_IPv6Net(list); end

    # summ_IPv4Net summarizes a list of IPv4Net objects as much as possible.
    # It will return a new list with any non IPv4Net objects removed.
    #
    # source://netaddr//lib/netaddr.rb#104
    def summ_IPv4Net(list); end

    # summ_IPv6Net summarizes a list of IPv6Net objects as much as possible.
    # It will return a new list with any non IPv6Net objects removed.
    #
    # source://netaddr//lib/netaddr.rb#116
    def summ_IPv6Net(list); end
  end
end

# EUI48 (Extended Unique Identifier 48-bit, or EUI-48) represents a 48-bit hardware address.
# It is typically associated with mac-addresses.
#
# source://netaddr//lib/eui48.rb#5
class NetAddr::EUI48
  # Create an EUI48 from an Integer. Must be between 0 and 2**48-1.
  # Throws ValidationError on error.
  #
  # @return [EUI48] a new instance of EUI48
  #
  # source://netaddr//lib/eui48.rb#12
  def initialize(i); end

  # addr is the Integer representation of this EUI
  #
  # source://netaddr//lib/eui48.rb#8
  def addr; end

  # bytes returns a list containing each byte of the EUI48 as String.
  #
  # source://netaddr//lib/eui48.rb#42
  def bytes; end

  # to_eui64 converts this EUI48 into an EUI64 by inserting 0xfffe between the first and last 24-bits of the address.
  #
  # source://netaddr//lib/eui48.rb#55
  def to_eui64; end

  # source://netaddr//lib/eui48.rb#59
  def to_s; end

  class << self
    # Parse an EUI-48 string into an EUI48 type.
    # This will successfully parse most of the typically used formats such as:
    # * aa-bb-cc-dd-ee-ff
    # * aa:bb:cc:dd:ee:ff
    # * aabb.ccdd.eeff
    # * aabbccddeeff
    #
    # Although, in truth, its not picky about the exact format as long as
    # it contains exactly 12 hex characters with the optional delimiting characters
    # '-', ':', or '.'.
    #
    # source://netaddr//lib/eui48.rb#31
    def parse(addr); end
  end
end

# EUI64 (Extended Unique Identifier 64-bit, or EUI-64) represents a 64-bit hardware address.
#
# source://netaddr//lib/eui64.rb#4
class NetAddr::EUI64
  # Create an EUI64 from an Integer. Must be between 0 and 2**64-1.
  # Throws ValidationError on error.
  #
  # @return [EUI64] a new instance of EUI64
  #
  # source://netaddr//lib/eui64.rb#11
  def initialize(i); end

  # addr is the Integer representation of this EUI
  #
  # source://netaddr//lib/eui64.rb#7
  def addr; end

  # bytes returns a list containing each byte of the EUI64 as a String.
  #
  # source://netaddr//lib/eui64.rb#41
  def bytes; end

  # to_ipv6 generates an IPv6 address from this EUI64 address and the provided IPv6Net.
  # Nil will be returned if net is not a /64.
  #
  # source://netaddr//lib/eui64.rb#56
  def to_ipv6(net); end

  # source://netaddr//lib/eui64.rb#71
  def to_s; end

  class << self
    # Parse an EUI-64 string into an EUI64 type.
    # This will successfully parse most of the typically used formats such as:
    # * aa-bb-cc-dd-ee-ff-00-11
    # * aa:bb:cc:dd:ee:ff:00:11
    # * aabb.ccdd.eeff.0011
    # * aabbccddeeff0011
    #
    # Although, in truth, its not picky about the exact format as long as
    # it contains exactly 16 hex characters with the optional delimiting characters
    # '-', ':', or '.'.
    #
    # source://netaddr//lib/eui64.rb#30
    def parse(addr); end
  end
end

# 128 bits worth of '1'
#
# source://netaddr//lib/netaddr.rb#18
NetAddr::F128 = T.let(T.unsafe(nil), Integer)

# 32 bits worth of '1'
#
# source://netaddr//lib/netaddr.rb#15
NetAddr::F32 = T.let(T.unsafe(nil), Integer)

# IPv4 represents a single IPv4 address.
#
# source://netaddr//lib/ipv4.rb#4
class NetAddr::IPv4
  # Create an IPv4 from an Integer. Must be between 0 and 2**32-1.
  # Throws ValidationError on error.
  #
  # @return [IPv4] a new instance of IPv4
  #
  # source://netaddr//lib/ipv4.rb#10
  def initialize(i); end

  # addr is the Integer representation of this IP address
  #
  # source://netaddr//lib/ipv4.rb#6
  def addr; end

  # cmp compares equality with another IPv4. Return:
  # * 1 if this IPv4 is numerically greater
  # * 0 if the two are equal
  # * -1 if this IPv4 is numerically less
  #
  # source://netaddr//lib/ipv4.rb#31
  def cmp(other); end

  # multicast_mac returns the EUI48 multicast mac-address for this IP.
  # It will return the zero address for IPs outside of the multicast range 224.0.0.0/4.
  #
  # source://netaddr//lib/ipv4.rb#45
  def multicast_mac; end

  # next returns the next consecutive IPv4 or nil if the address space is exceeded
  #
  # source://netaddr//lib/ipv4.rb#55
  def next; end

  # prev returns the preceding IPv4 or nil if this is 0.0.0.0
  #
  # source://netaddr//lib/ipv4.rb#63
  def prev; end

  # to_net returns the IPv4 as a IPv4Net
  #
  # source://netaddr//lib/ipv4.rb#71
  def to_net; end

  # to_s returns the IPv4 as a String
  #
  # source://netaddr//lib/ipv4.rb#76
  def to_s; end

  # version returns "4" for IPv4
  #
  # source://netaddr//lib/ipv4.rb#81
  def version; end

  class << self
    # parse will create an IPv4 from its string representation (ie. "192.168.1.1").
    # Throws ValidationError on error.
    #
    # source://netaddr//lib/ipv4.rb#21
    def parse(ip); end
  end
end

# IPv4Net represents an IPv4 network.
#
# source://netaddr//lib/ipv4net.rb#4
class NetAddr::IPv4Net
  # arguments:
  # * ip - an IPv4 object
  # * m32 - a Mask32 object. will default to a /32 if nil
  #
  # @return [IPv4Net] a new instance of IPv4Net
  #
  # source://netaddr//lib/ipv4net.rb#9
  def initialize(ip, m32); end

  # cmp compares equality with another IPv4Net. Return:
  # * 1 if this IPv4Net is numerically greater
  # * 0 if the two are equal
  # * -1 if this IPv4Net is numerically less
  #
  # The comparison is initially performed on using the cmp() method of the network address, however, in cases where the network
  # addresses are identical then the netmasks will be compared with the cmp() method of the netmask.
  #
  # source://netaddr//lib/ipv4net.rb#53
  def cmp(other); end

  # contains returns true if the IPv4Net contains the IPv4
  #
  # source://netaddr//lib/ipv4net.rb#65
  def contains(ip); end

  # extended returns the IPv4Net in extended format (eg. x.x.x.x y.y.y.y)
  #
  # source://netaddr//lib/ipv4net.rb#42
  def extended; end

  # fill returns a copy of the given Array, stripped of any networks which are not subnets of this IPv4Net
  # and with any missing gaps filled in.
  #
  # source://netaddr//lib/ipv4net.rb#77
  def fill(list); end

  # len returns the number of IP addresses in this network. It will return 0 for /0 networks.
  #
  # source://netaddr//lib/ipv4net.rb#93
  def len; end

  # netmask returns the Mask32 object representing the netmask for this network
  #
  # source://netaddr//lib/ipv4net.rb#83
  def netmask; end

  # network returns the IPv4 object representing the network address
  #
  # source://netaddr//lib/ipv4net.rb#88
  def network; end

  # next returns the next largest consecutive IP network or nil if the end of the address space is reached.
  #
  # source://netaddr//lib/ipv4net.rb#98
  def next; end

  # next_sib returns the network immediately following this one or nil if the end of the address space is reached.
  #
  # source://netaddr//lib/ipv4net.rb#107
  def next_sib; end

  # nth returns the IPv4 at the given index.
  # The size of the network may be determined with the len() method.
  # If the range is exceeded then return nil.
  #
  # source://netaddr//lib/ipv4net.rb#114
  def nth(index); end

  # nth_subnet returns the subnet IPv4Net at the given index.
  # The number of subnets may be determined with the subnet_count() method.
  # If the range is exceeded  or an invalid prefix_len is provided then return nil.
  #
  # source://netaddr//lib/ipv4net.rb#126
  def nth_subnet(prefix_len, index); end

  # prev returns the previous largest consecutive IP network or nil if this is 0.0.0.0.
  #
  # source://netaddr//lib/ipv4net.rb#136
  def prev; end

  # prev_sib returns the network immediately preceding this one or nil if this network is 0.0.0.0.
  #
  # source://netaddr//lib/ipv4net.rb#142
  def prev_sib; end

  # rel determines the relationship to another IPv4Net. Returns:
  # * 1 if this IPv4Net is the supernet of other
  # * 0 if the two are equal
  # * -1 if this IPv4Net is a subnet of other
  # * nil if the networks are unrelated
  #
  # source://netaddr//lib/ipv4net.rb#157
  def rel(other); end

  # resize returns a copy of the network with an adjusted netmask.
  # Throws ValidationError on invalid prefix_len.
  #
  # source://netaddr//lib/ipv4net.rb#181
  def resize(prefix_len); end

  # subnet_count returns the number a subnets of a given prefix length that this IPv4Net contains.
  # It will return 0 for invalid requests (ie. bad prefix or prefix is shorter than that of this network).
  # It will also return 0 if the result exceeds the capacity of a 32-bit integer (ie. if you want the # of /32 a /0 will hold)
  #
  # source://netaddr//lib/ipv4net.rb#189
  def subnet_count(prefix_len); end

  # summ creates a summary address from this IPv4Net and another.
  # It returns nil if the two networks are incapable of being summarized.
  #
  # source://netaddr//lib/ipv4net.rb#198
  def summ(other); end

  # to_s returns the IPv4Net as a String
  #
  # source://netaddr//lib/ipv4net.rb#219
  def to_s; end

  # version returns "4" for IPv4
  #
  # source://netaddr//lib/ipv4net.rb#224
  def version; end

  protected

  # grow decreases the prefix length as much as possible without crossing a bit boundary.
  #
  # source://netaddr//lib/ipv4net.rb#232
  def grow; end

  # nth_next_sib returns the nth next sibling network or nil if address space exceeded.
  #
  # source://netaddr//lib/ipv4net.rb#247
  def nth_next_sib(nth); end

  class << self
    # parse will create an IPv4Net from its string representation. Will default to a /32 netmask if not specified.
    # Throws ValidationError on error.
    #
    # source://netaddr//lib/ipv4net.rb#25
    def parse(net); end
  end
end

# IPv6 represents a single IPv6 address.
#
# source://netaddr//lib/ipv6.rb#4
class NetAddr::IPv6
  # Create an IPv6 from an Integer. Must be between 0 and 2**128-1.
  # Throws ValidationError on error.
  #
  # @return [IPv6] a new instance of IPv6
  #
  # source://netaddr//lib/ipv6.rb#10
  def initialize(i); end

  # addr is the Integer representation of this IP address
  #
  # source://netaddr//lib/ipv6.rb#6
  def addr; end

  # cmp compares equality with another IPv6. Return:
  # * 1 if this IPv6 is numerically greater
  # * 0 if the two are equal
  # * -1 if this IPv6 is numerically less
  #
  # source://netaddr//lib/ipv6.rb#31
  def cmp(other); end

  # ipv4 generates an IPv4 from an IPv6 address. The IPv4 address is generated based on the mechanism described by RFC 6052.
  # The argument pl (prefix length) should be one of: 32, 40, 48, 56, 64, or 96. Default is 96 unless one of the supported values is provided.
  #
  # source://netaddr//lib/ipv6.rb#45
  def ipv4(pl = T.unsafe(nil)); end

  # long returns the IPv6 as a string in long (uncompressed) format
  #
  # source://netaddr//lib/ipv6.rb#69
  def long; end

  # next returns the next consecutive IPv6 or nil if the address space is exceeded
  #
  # source://netaddr//lib/ipv6.rb#79
  def next; end

  # prev returns the preceding IPv6 or nil if this is 0.0.0.0
  #
  # source://netaddr//lib/ipv6.rb#87
  def prev; end

  # to_net returns the IPv6 as a IPv6Net
  #
  # source://netaddr//lib/ipv6.rb#95
  def to_net; end

  # to_s returns the IPv6 as a String in zero-compressed format (per rfc5952).
  #
  # source://netaddr//lib/ipv6.rb#100
  def to_s; end

  # version returns "6" for IPv6
  #
  # source://netaddr//lib/ipv6.rb#140
  def version; end

  class << self
    # parse will create an IPv6 from its string representation (ie. "1::").
    # Throws ValidationError on error.
    #
    # source://netaddr//lib/ipv6.rb#21
    def parse(ip); end
  end
end

# IPv6Net represents an IPv6 network.
#
# source://netaddr//lib/ipv6net.rb#4
class NetAddr::IPv6Net
  # arguments:
  # * ip - an IPv6 object
  # * m128 - a Mask128 object. will default to a /64 if nil
  #
  # @return [IPv6Net] a new instance of IPv6Net
  #
  # source://netaddr//lib/ipv6net.rb#9
  def initialize(ip, m128); end

  # cmp compares equality with another IPv6Net. Return:
  # * 1 if this IPv6Net is numerically greater
  # * 0 if the two are equal
  # * -1 if this IPv6Net is numerically less
  #
  # The comparison is initially performed on using the cmp() method of the network address, however, in cases where the network
  # addresses are identical then the netmasks will be compared with the cmp() method of the netmask.
  #
  # source://netaddr//lib/ipv6net.rb#49
  def cmp(other); end

  # contains returns true if the IPv6Net contains the IPv6
  #
  # source://netaddr//lib/ipv6net.rb#61
  def contains(ip); end

  # fill returns a copy of the given Array, stripped of any networks which are not subnets of this IPv6Net
  # and with any missing gaps filled in.
  #
  # source://netaddr//lib/ipv6net.rb#73
  def fill(list); end

  # len returns the number of IP addresses in this network. It will return 0 for /0 networks.
  #
  # source://netaddr//lib/ipv6net.rb#79
  def len; end

  # long returns the IPv6Net as a string in long (uncompressed) format
  #
  # source://netaddr//lib/ipv6net.rb#84
  def long; end

  # netmask returns the Mask128 object representing the netmask for this network
  #
  # source://netaddr//lib/ipv6net.rb#89
  def netmask; end

  # network returns the IPv6 object representing the network address
  #
  # source://netaddr//lib/ipv6net.rb#94
  def network; end

  # next returns the next largest consecutive IP network or nil if the end of the address space is reached.
  #
  # source://netaddr//lib/ipv6net.rb#99
  def next; end

  # next_sib returns the network immediately following this one or nil if the end of the address space is reached.
  #
  # source://netaddr//lib/ipv6net.rb#108
  def next_sib; end

  # nth returns the IPv6 at the given index.
  # The size of the network may be determined with the len() method.
  # If the range is exceeded then return nil.
  #
  # source://netaddr//lib/ipv6net.rb#115
  def nth(index); end

  # nth_subnet returns the subnet IPv6Net at the given index.
  # The number of subnets may be determined with the subnet_count() method.
  # If the range is exceeded  or an invalid prefix_len is provided then return nil.
  #
  # source://netaddr//lib/ipv6net.rb#127
  def nth_subnet(prefix_len, index); end

  # prev returns the previous largest consecutive IP network or nil if this is ::.
  #
  # source://netaddr//lib/ipv6net.rb#137
  def prev; end

  # prev_sib returns the network immediately preceding this one or nil if this network is ::.
  #
  # source://netaddr//lib/ipv6net.rb#143
  def prev_sib; end

  # rel determines the relationship to another IPv6Net. Returns:
  # * 1 if this IPv6Net is the supernet of other
  # * 0 if the two are equal
  # * -1 if this IPv6Net is a subnet of other
  # * nil if the networks are unrelated
  #
  # source://netaddr//lib/ipv6net.rb#161
  def rel(other); end

  # resize returns a copy of the network with an adjusted netmask.
  # Throws ValidationError on invalid prefix_len.
  #
  # source://netaddr//lib/ipv6net.rb#185
  def resize(prefix_len); end

  # subnet_count returns the number a subnets of a given prefix length that this IPv6Net contains.
  # It will return 0 for invalid requests (ie. bad prefix or prefix is shorter than that of this network).
  # It will also return 0 if the result exceeds the capacity of a 128-bit integer (ie. if you want the # of /128 a /0 will hold)
  #
  # source://netaddr//lib/ipv6net.rb#193
  def subnet_count(prefix_len); end

  # summ creates a summary address from this IPv6Net and another.
  # It returns nil if the two networks are incapable of being summarized.
  #
  # source://netaddr//lib/ipv6net.rb#202
  def summ(other); end

  # to_s returns the IPv6Net as a String
  #
  # source://netaddr//lib/ipv6net.rb#223
  def to_s; end

  # version returns "6" for IPv6
  #
  # source://netaddr//lib/ipv6net.rb#228
  def version; end

  protected

  # grow decreases the prefix length as much as possible without crossing a bit boundary.
  #
  # source://netaddr//lib/ipv6net.rb#236
  def grow; end

  # nth_next_sib returns the nth next sibling network or nil if address space exceeded.
  #
  # source://netaddr//lib/ipv6net.rb#252
  def nth_next_sib(nth); end

  class << self
    # parse will create an IPv6Net from its string representation. A default netmask will be used if not specified.
    # Throws ValidationError on error.
    #
    # source://netaddr//lib/ipv6net.rb#29
    def parse(net); end
  end
end

# Mask128 represents a 128-bit netmask.
#
# source://netaddr//lib/mask128.rb#4
class NetAddr::Mask128
  # Create a Mask128 from an Integer prefix length. Valid values are 0-128.
  # Throws ValidationError on error.
  #
  # @return [Mask128] a new instance of Mask128
  #
  # source://netaddr//lib/mask128.rb#13
  def initialize(prefix_len); end

  # cmp compares equality with another Mask128. Return:
  # * 1 if this Mask128 is larger in capacity
  # * 0 if the two are equal
  # * -1 if this Mask128 is smaller in capacity
  #
  # source://netaddr//lib/mask128.rb#42
  def cmp(other); end

  # len returns the number of IP addresses in this network. This is only useful if you have a subnet
  # smaller than a /64 as it will always return 0 for prefixes <= 64.
  #
  # source://netaddr//lib/mask128.rb#56
  def len; end

  # mask is the Integer representation of this netmask
  #
  # source://netaddr//lib/mask128.rb#6
  def mask; end

  # prefix_len is the Integer prefix length of this netmask
  #
  # source://netaddr//lib/mask128.rb#9
  def prefix_len; end

  # to_s returns the Mask128 as a String
  #
  # source://netaddr//lib/mask128.rb#64
  def to_s; end

  class << self
    # parse will create an Mask128 from its string representation.
    # arguments:
    # * mask - String representing an netmask (ie. "/64").
    #
    # Throws ValidationError on error.
    #
    # source://netaddr//lib/mask128.rb#28
    def parse(mask); end
  end
end

# Mask32 represents a 32-bit netmask.
#
# source://netaddr//lib/mask32.rb#4
class NetAddr::Mask32
  # Create a Mask32 from an Integer prefix length. Valid values are 0-32.
  # Throws ValidationError on error.
  #
  # @return [Mask32] a new instance of Mask32
  #
  # source://netaddr//lib/mask32.rb#13
  def initialize(prefix_len); end

  # cmp compares equality with another Mask32. Return:
  # * 1 if this Mask128 is larger in capacity
  # * 0 if the two are equal
  # * -1 if this Mask128 is smaller in capacity
  #
  # source://netaddr//lib/mask32.rb#78
  def cmp(other); end

  # extended returns the Mask32 in extended format (eg. x.x.x.x)
  #
  # source://netaddr//lib/mask32.rb#70
  def extended; end

  # len returns the number of IP addresses in this network. It will always return 0 for /0 networks.
  #
  # source://netaddr//lib/mask32.rb#91
  def len; end

  # mask is the Integer representation of this netmask
  #
  # source://netaddr//lib/mask32.rb#6
  def mask; end

  # prefix_len is the Integer prefix length of this netmask
  #
  # source://netaddr//lib/mask32.rb#9
  def prefix_len; end

  # to_s returns the Mask32 as a String
  #
  # source://netaddr//lib/mask32.rb#99
  def to_s; end

  class << self
    # parse will create an Mask32 from its string representation.
    # arguments:
    # * mask - String representing a netmask (ie. "/24" or "255.255.255.0").
    #
    # Throws ValidationError on error.
    #
    # source://netaddr//lib/mask32.rb#28
    def parse(mask); end
  end
end

# Contains various internal util functions
#
# source://netaddr//lib/util.rb#4
class NetAddr::Util
  class << self
    # backfill generates subnets between given IPv4Net/IPv6Net and the limit address.
    # limit should be < ipnet. will create subnets up to and including limit.
    #
    # source://netaddr//lib/util.rb#9
    def backfill(ipnet, limit); end

    # discard_subnets returns a copy of the IPv4NetList with any entries which are subnets of other entries removed.
    #
    # source://netaddr//lib/util.rb#25
    def discard_subnets(list); end

    # fill returns a copy of the given Array, stripped of any networks which are not subnets of ipnet
    # and with any missing gaps filled in.
    #
    # source://netaddr//lib/util.rb#51
    def fill(ipnet, list); end

    # filter_IPv4 returns a copy of list with only IPv4 objects
    #
    # source://netaddr//lib/util.rb#84
    def filter_IPv4(list); end

    # filter_IPv4Net returns a copy of list with only IPv4Net objects
    #
    # source://netaddr//lib/util.rb#95
    def filter_IPv4Net(list); end

    # filter_IPv6 returns a copy of list with only IPv6 objects
    #
    # source://netaddr//lib/util.rb#106
    def filter_IPv6(list); end

    # filter_IPv6Net returns a copy of list with only IPv4Net objects
    #
    # source://netaddr//lib/util.rb#117
    def filter_IPv6Net(list); end

    # fwdfill returns subnets between given IPv4Net/IPv6Nett and the limit address. limit should be > ipnet.
    #
    # source://netaddr//lib/util.rb#128
    def fwdfill(ipnet, supernet, limit); end

    # int_to_IPv4 converts an Integer into an IPv4 address String
    #
    # source://netaddr//lib/util.rb#206
    def int_to_IPv4(i); end

    # parse_IPv4 parses an IPv4 address String into an Integer
    #
    # source://netaddr//lib/util.rb#216
    def parse_IPv4(ip); end

    # parse_IPv6 parses an IPv6 address String into an Integer
    #
    # source://netaddr//lib/util.rb#241
    def parse_IPv6(ip); end

    # quick_sort will return a sorted copy of the provided Array.
    # The array must contain only objects which implement a cmp method and which are comparable to each other.
    #
    # source://netaddr//lib/util.rb#311
    def quick_sort(list); end

    # summ_peers returns a copy of the list with any merge-able subnets summ'd together.
    #
    # source://netaddr//lib/util.rb#338
    def summ_peers(list); end
  end
end

# ValidationError is thrown when a method fails a validation test.
#
# source://netaddr//lib/netaddr.rb#22
class NetAddr::ValidationError < ::StandardError; end
